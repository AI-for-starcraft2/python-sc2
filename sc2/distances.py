from sc2.position import Point2
from sc2.unit import Unit
from sc2.units import Units
from sc2.game_state import GameState

import logging

logger = logging.getLogger(__name__)

from scipy.spatial.distance import cdist, pdist
import math
import numpy as np

try:
    from numba import njit

    _numba_imported = True
except:
    logger.error(
        f"Could not import numba in file {__file__}. Please install numba to have faster distance calculations using command 'pip install numba'"
    )
    _numba_imported = False

from typing import List, Dict, Tuple, Iterable, Generator


class DistanceCalculation:
    def __init__(self):
        self.state: GameState = None
        self._generated_frame = -100
        self._generated_frame2 = -100
        # A Dictionary with a dict positions: index of the pdist condensed matrix
        self.__unit_index_dict: Dict[Tuple[float, float], int] = None
        # Pdist condensed vector generated by scipy pdist
        self.__pdist = None

    @property
    def _unit_index_dict(self):
        if self._generated_frame != self.state.game_loop:
            return self.generate_unit_indices()
        return self.__unit_index_dict

    @property
    def _pdist(self):
        if self._generated_frame2 != self.state.game_loop:
            return self.calculate_distances()
        return self.__pdist

    def generate_unit_indices(self):
        if self._generated_frame != self.state.game_loop:
            self.__unit_index_dict = {unit.position_tuple: index for index, unit in enumerate(self.units)}
            self._generated_frame = self.state.game_loop
        return self.__unit_index_dict

    def calculate_distances(self):
        if self._generated_frame2 != self.state.game_loop:
            positions_array: np.ndarray = np.fromiter(
                self._unit_index_dict.keys(), dtype=np.float, count=len(self._unit_index_dict)
            )
            self._generated_frame2 = self.state.game_loop
            # See performance benchmarks
            self.__pdist = pdist(positions_array, "sqeuclidean")
            # Using exact distance takes more time to compute
            # self._pdist = pdist(positions_array, "euclidean")
        return self.__pdist

    def _get_index_of_two_units(self, unit1: Unit, unit2: Unit):
        assert unit1.position_tuple in self._unit_index_dict, f"Unit {unit1} is not in index dict"
        assert unit2.position_tuple in self._unit_index_dict, f"Unit {unit2} is not in index dict"
        index1 = self._unit_index_dict[unit1.position_tuple]
        index2 = self._unit_index_dict[unit2.position_tuple]
        condensed_index = self.square_to_condensed(index1, index2)
        return condensed_index

    def _get_index_of_two_positions(self, pos1: Tuple[float, float], pos2: Tuple[float, float]):
        assert pos1 in self._unit_index_dict, f"Position {pos1} is not in index dict"
        assert pos2.position_tuple in self._unit_index_dict, f"Position {pos2} is not in index dict"
        index1 = self._unit_index_dict[pos1]
        index2 = self._unit_index_dict[pos2]
        condensed_index = self.square_to_condensed(index1, index2)
        return condensed_index

    # Helper functions

    def square_to_condensed(self, i, j):
        # Converts indices of a square matrix to condensed matrix
        # https://stackoverflow.com/a/36867493/10882657
        assert i != j, "No diagonal elements in condensed matrix! Diagonal elements are zero"
        if i < j:
            i, j = j, i
        return len(self._unit_index_dict) * j - j * (j + 1) // 2 + i - 1 - j

    def convert_tuple_to_numpy_array(self, pos: Tuple[float, float]):
        """ Converts a single position to a 2d numpy array with 1 row and 2 columns. """
        return np.fromiter(pos, dtype=float, count=2).reshape((1, 2))

    # Fast calculation functions

    def distance_math_hypot(self, p1: Tuple[float, float], p2: Tuple[float, float]):
        return math.hypot(p1[0] - p2[0], p1[1] - p2[1])

    # Distance calculation using the pre-calculated matrix above

    def _distance_squared_unit_to_unit(self, unit1: Unit, unit2: Unit):
        condensed_index = self._get_index_of_two_units(unit1, unit2)
        distance = self._pdist[condensed_index]
        return distance

    def _distance_squared_pos_to_pos(self, pos1: Tuple[float, float], pos2: Tuple[float, float]):
        assert pos1 in self._unit_index_dict
        assert pos2 in self._unit_index_dict
        condensed_index = self._get_index_of_two_positions(pos1, pos2)
        distance = self._pdist[condensed_index]
        return distance

    # Distance calculation using the fastest distance calculation functions

    def _distance_pos_to_pos(self, pos1: Tuple[float, float], pos2: Tuple[float, float]):
        return self.distance_math_hypot(pos1, pos2)

    def _distance_units_to_pos(self, units: Units, pos: Tuple[float, float]) -> Generator[float, None, None]:
        """ This function does not scale well, if len(units) > 100 it gets fairly slow """
        return (self.distance_math_hypot(u.position_tuple, pos) for u in units)

    def _distance_unit_to_points(self, unit: Unit, points: Iterable[Tuple[float, float]]) -> Generator[float, None, None]:
        """ This function does not scale well, if len(points) > 100 it gets fairly slow """
        pos = unit.position_tuple
        return (self.distance_math_hypot(p, pos) for p in points)
